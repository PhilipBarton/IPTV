<html>
    <head>
        <link href="https://unpkg.com/@primer/css/dist/primer.css" rel="stylesheet" />
        <style>
            img{
  width:50px;
            }
.Box-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        /* The snackbar - position it at the bottom and in the middle of the screen */
        #snackbar {
            visibility: hidden;
            position: fixed;
            z-index: 1;
            left: 50%;
            bottom: 30px;
        }

        /* Show the snackbar when clicking on a button (class added with JavaScript) */
        #snackbar.show {
            visibility: visible;
            -webkit-animation: fadein 0.5s, fadeout 0.5s 1s;
            animation: fadein 0.5s, fadeout 0.5s 1s;
        }

        /* Animations to fade the snackbar in and out */
        @-webkit-keyframes fadein {
            from {
                bottom: 0;
                opacity: 0;
            }

            to {
                bottom: 30px;
                opacity: 1;
            }
        }

        @keyframes fadein {
            from {
                bottom: 0;
                opacity: 0;
            }

            to {
                bottom: 30px;
                opacity: 1;
            }
        }

        @-webkit-keyframes fadeout {
            from {
                bottom: 30px;
                opacity: 1;
            }

            to {
                bottom: 0;
                opacity: 0;
            }
        }

        @keyframes fadeout {
            from {
                bottom: 30px;
                opacity: 1;
            }

            to {
                bottom: 0;
                opacity: 0;
            }
            }
.column {
  
  width: 70%;
}
            .small{
                width:30%!important;
            }
            .row{
                display:flex;
                width:100%;
            }
body {
        width:100%;
        display: inline-flex;
        flex-wrap: wrap;
}
/* Clear floats after the columns */
.row:after {
  content: "";
  display: table;
  clear: both;
}
        </style>
    </head>
<body> 
    
    <div class="row">
        <div class="column small">
            <h1>
            Convert M3U file to HTML
        </h1>
        <div class="col-xs-12 col-md-6 mt-3">
            <div class="Box box-shadow">
                <div class="Box-row">
                    <label for="file-selector">Upload a M3U file</label>
                    <input type="file" id="file-selector">
                </div>
            </div>
        </div>
        <div class="col-xs-12 mt-2">
            <div id="loader">
                <span class="mt-2">Loading<span class="AnimatedEllipsis"></span></span>
            </div>
    <ul>
     
            
        
            <div id="main">
                <input class="form-control input-block" type="text" id="search-input" onkeyup="search()"
                       placeholder="Search" title="Type in a keyword">
                <div id="list" class="Box mt-2">
                    <div class="Box-header">
                        <select id="select" onchange="filterItems(this)" class="form-select">
                            <option value="all">All Visible</option>
                        </select>
                    </div>
                </div>
                <p id="status"></p>
            </div>
            <div class="mt-5">
                You can use <a href="https://raw.githubusercontent.com/a133xz/m3u-to-html/master/example.m3u"
                   target="_blank">this file</a> as example.

                <p> Learn more about the project <a href="https://github.com/a133xz/m3u-to-html">on github.</a> You can
                    also <a href="https://antonio-r.now.sh/" target="_blank">visit my site ü§∑‚Äç‚ôÇÔ∏è</a> .</p>
            </div>
            <div id="snackbar">
                <div class="Toast Toast--success">
                    <span class="Toast-icon">
                        <!-- <%= octicon "check" %> -->
                        <svg width="12" height="16" viewBox="0 0 12 16" class="octicon octicon-check"
                             aria-hidden="true">
                            <path fill-rule="evenodd" d="M12 5l-8 8-4-4 1.5-1.5L4 10l6.5-6.5L12 5z" />
                        </svg>
                    </span>
                    <span class="Toast-content">Link copied</span>
                </div>
            </div>
        </div>

            
  </ul>
            
        
            
        </div>
    <div class=" column">  
        <audio src="https://raw.githubusercontent.com/PhilipBarton/IPTV/PhilipBarton-patch-1/Tv.m3u" controls="controls">
not supported?
</audio><noscript>Playback without Javascript needs native m3u-support. Just copy the link
<a href="https://raw.githubusercontent.com/PhilipBarton/IPTV/PhilipBarton-patch-1/Tv.m3u">m3u-player-example-playlist.m3u</a>

and run it with a media player.</noscript>
        <h1>hey</h1>
        <iframe width="70%" height="3000px" src="https://tvlistings.zap2it.com/?aid=gapzap" title="W3Schools Free Online Web Tutorials"></iframe>
</div>
    </div>

       <script>
  const main = document.getElementById("main");
const status = document.getElementById("status");
const select = document.getElementById("select");
const loader = document.getElementById("loader");
const listDiv = document.getElementById("list");
const input = document.getElementById("search-input");
const snackbar = document.getElementById("snackbar");

loader.style.display = "none";
main.style.display = "none";

// Possible external variables
const splitBy = "EXTINF:-1";
const keysToParse = { name: "tvg-name", logo: "tvg-logo" };

// Get group of values
const getValuesByKey = (string, key) => {
  const regx = new RegExp(`${key}="(.*?)"`);
  const value = string.match(regx);
  if (value && value.length) {
    return value[1];
  }
  return "";
};
// Get Link
const getLink = (string) => {
  const regx =("/http[s]*:\/\/[^\/]+(\/.+)/") ;
  const value = string.match(regx);
  if (value && value.length) {
    return value[0];
  }
  return "";
};

// Alert
var timeOut;
var stopTimeOut = function () {
  snackbar.classList.remove("show");
  clearTimeout(timeOut);
};
var setAlert = function () {
  timeOut = setTimeout(function () {
    snackbar.classList.remove("show");
  }, 1300);
};

// Copy URL
async function copy_url(url) {
  try {
    await navigator.clipboard.writeText(url);
    console.log("Text or Page URL copied");
    stopTimeOut();
    // Add the "show" class to DIV
    snackbar.className = "show";
    // After 3 seconds, remove the show class from DIV
    setAlert();
  } catch (err) {
    console.error("Failed to copy: ", err);
  }
}
// The constructor
function Channel(name, logo, link) {
  this.name = name;
  this.logo = logo;
  this.link = link;
}

if (window.FileList && window.File && window.FileReader) {
  document
    .getElementById("file-selector")
    .addEventListener("change", (event) => {
      status.textContent = "";
      loader.style.display = "block";
      const obj = [];
      const filters = new Set();
      const file = event.target.files[0];
      if (!file.type) {
        status.textContent =
          "Error: The File.type property does not appear to be supported on this browser.";
        return;
      }
      const reader = new FileReader();
      reader.readAsText(file, "UTF-8");
      reader.onload = function (evt) {
        const results = evt.target.result;
        results.split(splitBy).map(function (channel) {
          const name = getValuesByKey(channel, keysToParse.name);
          const group = getValuesByKey(channel, keysToParse.logo);
          const link = getLink(channel);
          if (link) {
            // if group equal...
            return obj.push(new Channel(name, logo, link));
          }
          return [];
        });
        const ul = document.createElement("ul");
        for (let i = 0; i < obj.length; ++i) {
          const anchor = document.createElement("a");
          const li = document.createElement("li");
          anchor.href = obj[i].link;
          anchor.textContent = obj[i].name;
          li.appendChild(anchor);
          li.insertAdjacentHTML(
            "beforeend",
            `<button class="btn mr-2" type="button" aria-label="Copy icon" onclick="copy_url('${obj[i].link}')">
        <svg aria-hidden="true" role="img" class="octicon" viewBox="0 0 16 16" width="16" height="16" fill="currentColor" style="display: inline-block; user-select: none; vertical-align: text-bottom;"><path fill-rule="evenodd" d="M5.75 1a.75.75 0 00-.75.75v3c0 .414.336.75.75.75h4.5a.75.75 0 00.75-.75v-3a.75.75 0 00-.75-.75h-4.5zm.75 3V2.5h3V4h-3zm-2.874-.467a.75.75 0 00-.752-1.298A1.75 1.75 0 002 3.75v9.5c0 .966.784 1.75 1.75 1.75h8.5A1.75 1.75 0 0014 13.25v-9.5a1.75 1.75 0 00-.874-1.515.75.75 0 10-.752 1.298.25.25 0 01.126.217v9.5a.25.25 0 01-.25.25h-8.5a.25.25 0 01-.25-.25v-9.5a.25.25 0 01.126-.217z"></path></svg>
      </button>`
          );
          li.setAttribute("group", obj[i].logo);
          li.classList.add("Box-row");
          filters.add(obj[i].logo);
          ul.appendChild(li);
          ul.id = "list-items";
        }
        listDiv.appendChild(ul);
        const filtersArr = Array.from(filters);
        for (let i = 0; i < filtersArr.length; i++) {
          var opt = filtersArr[i];
          var el = document.createElement("option");
          el.textContent = opt;
          el.value = opt;
          select.appendChild(el);
        }
        loader.style.display = "none";
        main.style.display = "block";
      };
      reader.onerror = function (evt) {
        status.textContent = "error reading file";
      };
    });
}

// Events from HTML
function filterItems(select) {
  const divSelect = select.value;
  const ul = document.getElementById("list-items");
  const li = ul.getElementsByTagName("li");
  for (let i = 0; i < li.length; i++) {
    let nodeValue = li[i].attributes.group.nodeValue;
    if (divSelect === "all") {
      li[i].style.display = "";
    } else {
      if (divSelect == nodeValue) {
        li[i].style.display = "";
      } else {
        li[i].style.display = "none";
      }
    }
  }
}

function search() {
  const filter = input.value.toUpperCase();
  const ul = document.getElementById("list-items");
  const li = ul.getElementsByTagName("li");
  for (let i = 0; i < li.length; i++) {
    let item = li[i].getElementsByTagName("a")[0];
    let textValue = item.textContent || item.innerText;
    if (textValue.toUpperCase().indexOf(filter) > -1) {
      li[i].style.display = "";
    } else {
      li[i].style.display = "none";
    }
  }
}
       </script>
    <script>
        // [[file:m3u-player.org::*The script][The script:1]]
// @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&dn=gpl-2.0.txt GPL-v2-or-Later
const nodes = document.querySelectorAll("audio,video");
const playlists = {};
const prefetchedTracks = new Map(); // use a map for insertion order, so we can just blow away old entries.
// maximum prefetched blobs that are kept.
const MAX_PREFETCH_KEEP = 10;
// maximum allowed number of entries in a playlist to prevent OOM attacks against the browser with self-referencing playlists
const MAX_PLAYLIST_LENGTH = 1000;
const PLAYLIST_MIME_TYPES = ["audio/x-mpegurl", "audio/mpegurl", "application/vnd.apple.mpegurl","application/mpegurl","application/x-mpegurl"];
function stripUrlParameters(link) {
  const url = new URL(link, window.location);
  url.search = "";
  url.hash = "";
  return url.href;
}
function isPlaylist(link) {
  const linkHref = stripUrlParameters(link);
  return linkHref.endsWith(".m3u") || linkHref.endsWith(".m3u8");
}
function isBlob(link) {
  return new URL(link, window.location).protocol == 'blob';
}
function parsePlaylist(textContent) {
  return textContent.match(/^(?!#)(?!\s).*$/mg)
    .filter(s => s); // filter removes empty strings
}
/**
 * Download the given playlist, parse it, and store the tracks in the
 * global playlists object using the url as key.
 *
 * Runs callback once the playlist downloaded successfully.
 */
function fetchPlaylist(url, onload, onerror) {
  const playlistFetcher = new XMLHttpRequest();
  playlistFetcher.open("GET", url, true);
  playlistFetcher.responseType = "blob"; // to get a mime type
  playlistFetcher.onload = () => {
    if (PLAYLIST_MIME_TYPES.includes(playlistFetcher.response.type)) { // security check to ensure that filters have run
      const reader = new FileReader();
      const load = onload; // propagate to inner scope
      reader.addEventListener("loadend", e => {
        playlists[url] = parsePlaylist(reader.result);
        onload();
      });
      reader.readAsText(playlistFetcher.response);
    } else {
      console.error("playlist must have one of the playlist MIME type '" + PLAYLIST_MIME_TYPES + "' but it had MIME type '" + playlistFetcher.response.type + "'.");
      onerror();
    }
  };
  playlistFetcher.onerror = onerror;
  playlistFetcher.abort = onerror;
  playlistFetcher.send();
}
function servedPartialDataAndCanRequestAll (xhr) {
  if (xhr.status === 206) {
    if (xhr.getResponseHeader("content-range").includes("/")) {
      if (!xhr.getResponseHeader("content-range").includes("/*")) {
        return true;
      }
    }
  }
  return false;
}
function prefetchTrack(url, onload) {
  if (prefetchedTracks.has(url)) {
    return;
  }
  // first cleanup: kill the oldest entries until we're back at the allowed size
  while (prefetchedTracks.size > MAX_PREFETCH_KEEP) {
    const key = prefetchedTracks.keys().next().value;
    const track = prefetchedTracks.get(key);
    prefetchedTracks.delete(key);
  }
  // first set the prefetched to the url so we will never request twice
  prefetchedTracks.set(url, url);
  // now start replacing it with a blob
  const xhr = new XMLHttpRequest();
  xhr.open("GET", url, true);
  xhr.responseType = "blob";
  xhr.onload = () => {
    if (servedPartialDataAndCanRequestAll(xhr)) {
      const endRange = Number(xhr.getResponseHeader("content-range").split("/")[1]) - 1;
      const rangeXhr = new XMLHttpRequest();
      rangeXhr.open("GET", url, true);
      rangeXhr.responseType = "blob";
      rangeXhr.setRequestHeader("range", "bytes=0-" + endRange);
      rangeXhr.onload = () => {
        prefetchedTracks.set(url, rangeXhr.response);
        if (onload) {
          onload();
        }
      };
      rangeXhr.send();      
    } else {
      prefetchedTracks.set(url, xhr.response);
      if (onload) {
        onload();
      }
    }
  };
  xhr.send();
}

function showStaticOverlay(mediaTag, canvas) {
  if (mediaTag instanceof Audio) {
    return;
  }
  // take screenshot of video and overlay it to mask short-term flicker.
  const realWidth = mediaTag.getBoundingClientRect().width;
  const realHeight = mediaTag.getBoundingClientRect().height;
  canvas.width = realWidth;
  canvas.height = realHeight;
  // need the actual video size
  const videoAspectRatio = mediaTag.videoHeight / mediaTag.videoWidth;
  const tagAspectRatio = realHeight / realWidth;
  const videoIsPartialHeight = tagAspectRatio > (videoAspectRatio * 1.01); // avoid rounding errors
  const videoIsPartialWidth = videoAspectRatio > (tagAspectRatio * 1.01); // avoid rounding errors
  if (videoIsPartialHeight) {
    canvas.height = realWidth * videoAspectRatio;
  } else if (videoIsPartialWidth) {
    canvas.width = realHeight / videoAspectRatio;
  }
  const context = canvas.getContext("2d");
  context.scale(canvas.width / mediaTag.videoWidth, canvas.height / mediaTag.videoHeight);
  context.drawImage(mediaTag, 0, 0);
  canvas.hidden = true;
  mediaTag.parentNode.insertBefore(canvas, mediaTag.nextSibling);
  canvas.style.position = "absolute";
  // shift canvas to cover only the space where the video actually is
  if (videoIsPartialWidth) {
    canvas.style.marginLeft = "-" + ((realWidth + canvas.width) / 2.) + "px";
  } else {
    canvas.style.marginLeft = "-" + realWidth + "px";
  }
  if (videoIsPartialHeight) {
    canvas.style.marginTop = ((realHeight - canvas.height) / 2.) + "px";
  }
  canvas.hidden = false;
}

function updateSrc(mediaTag, callback) {
  const playlistUrl = mediaTag.getAttribute("playlist");
  const trackIndex =  mediaTag.getAttribute("track-index");
  // deepcopy playlists to avoid shared mutation
  let playlist = [...playlists[playlistUrl]];
  let trackUrl = playlist[trackIndex];
  // download and splice in playlists as needed
  if (isPlaylist(trackUrl)) {
    if (playlist.length >= MAX_PLAYLIST_LENGTH) {
      // skip playlist if we already have too many tracks
      changeTrack(mediaTag, +1);
    } else {
      // do not use the cached playlist here, though it is tempting: it might genuinely change to allow for updates
      fetchPlaylist(
        trackUrl,
        () => {
          playlist.splice(trackIndex, 1, ...playlists[trackUrl]);
          playlists[playlistUrl] = playlist;
          updateSrc(mediaTag, callback);
        },
        () => callback());
    }
  } else {
    let url = prefetchedTracks.has(trackUrl)
        ? prefetchedTracks.get(trackUrl) instanceof Blob
        ? URL.createObjectURL(prefetchedTracks.get(trackUrl))
        : trackUrl : trackUrl;
    const oldUrl = mediaTag.getAttribute("src");
    // prevent size flickering by setting height before src change
    const canvas = document.createElement("canvas");
    if (!isNaN(mediaTag.duration) // already loaded a valid file
       && document.fullscreen !== true) { // overlay does not work for fullscreen
      // mask flickering with a static overlay
      try {
        showStaticOverlay(mediaTag, canvas);
      } catch (error) {
        console.log(error);
      }
    }
    // force sizes to stay constant during loading of the next segment
    mediaTag.style.height = mediaTag.getBoundingClientRect().height.toString() + 'px';
    mediaTag.style.width = mediaTag.getBoundingClientRect().width.toString() + 'px';
    // swich to the next segment
    mediaTag.setAttribute("src", url);
    mediaTag.oncanplaythrough = () => {
      if (!isNaN(mediaTag.duration)) { // already loaded a valid file
        // unset element styles to allow recomputation if sizes changed
        mediaTag.style.height = null;
        mediaTag.style.width = null;
      }
      // remove overlay
      canvas.hidden = true;
      canvas.remove(); // to allow garbage collection
    };
    setTimeout(() => canvas.remove(), 300); // fallback
    // replace the url when done, because a blob from an xhr request
    // is more reliable in the media tag;
    // the normal URL caused jumping prematurely to the next track.
    if (url == trackUrl) {
      prefetchTrack(trackUrl, () => {
        if (mediaTag.paused) {
          if (url == mediaTag.getAttribute("src")) {
            if (mediaTag.currentTime === 0) {
              mediaTag.setAttribute("src", URL.createObjectURL(
                prefetchedTracks.get(url)));
            }
          }
        }
      });
    }
    // allow releasing memory
    if (isBlob(oldUrl)) {
      URL.revokeObjectURL(oldUrl);
    }
    // update title
    mediaTag.parentElement.querySelector(".m3u-player--title").title = trackUrl;
    mediaTag.parentElement.querySelector(".m3u-player--title").textContent = trackUrl;
    // start prefetching the next three tracks.
    for (const i of [1, 2, 3]) {
      if (playlist.length > Number(trackIndex) + i) {
        prefetchTrack(playlist[Number(trackIndex) + i]);
      }
    }
    callback();
  }
}
function changeTrack(mediaTag, diff) {
  const currentTrackIndex = Number(mediaTag.getAttribute("track-index"));
  const nextTrackIndex = currentTrackIndex + diff;
  const tracks = playlists[mediaTag.getAttribute("playlist")];
  if (nextTrackIndex >= 0) { // do not collapse the if clauses with double-and, that does not survive inlining
    if (tracks.length > nextTrackIndex) {
    mediaTag.setAttribute("track-index", nextTrackIndex);
      updateSrc(mediaTag, () => mediaTag.play());
    }
  }
}

/**
 * Turn a media tag into playlist player.
 */
function initPlayer(mediaTag) {
  mediaTag.setAttribute("playlist", mediaTag.getAttribute("src"));
  mediaTag.setAttribute("track-index", 0);
  const url = mediaTag.getAttribute("playlist");
  const wrapper = mediaTag.parentElement.insertBefore(document.createElement("div"), mediaTag);
  const controls = document.createElement("div");
  const left = document.createElement("span");
  const title = document.createElement("span");
  const right = document.createElement("span");
  controls.appendChild(left);
  controls.appendChild(title);
  controls.appendChild(right);
  left.classList.add("m3u-player--left");
  right.classList.add("m3u-player--right");
  title.classList.add("m3u-player--title");
  title.style.overflow = "hidden";
  title.style.textOverflow = "ellipsis";
  title.style.whiteSpace = "nowrap";
  title.style.opacity = "0.3";
  title.style.direction = "rtl"; // for truncation on the left
  title.style.paddingLeft = "0.5em";
  title.style.paddingRight = "0.5em";
  controls.style.display = "flex";
  controls.style.justifyContent = "space-between";
  const styleTag = document.createElement("style");
  styleTag.innerHTML = ".m3u-player--left:hover, .m3u-player--right:hover {color: wheat; background-color: DarkSlateGray}";
  wrapper.appendChild(styleTag);
  wrapper.appendChild(controls);
  controls.style.width = mediaTag.getBoundingClientRect().width.toString() + "px";
  // appending the media tag to the wrapper removes it from the outer scope but keeps the event listeners
  wrapper.appendChild(mediaTag);
  left.innerHTML = "&lt;"; // not textContent, because we MUST escape
                           // the tag here and textContent shows the
                           // escaped version
  left.onclick = () => changeTrack(mediaTag, -1);
  right.innerHTML = "&gt;";
  right.onclick = () => changeTrack(mediaTag, +1);
  fetchPlaylist(
    url,
    () => {
      updateSrc(mediaTag, () => null);
      mediaTag.addEventListener("ended", event => {
        if (mediaTag.currentTime >= mediaTag.duration) {
          changeTrack(mediaTag, +1);
        }
      });
    },
    () => null);
  // keep the controls aligned to the media tag
  mediaTag.resizeObserver = new ResizeObserver(entries => {
    controls.style.width = entries[0].contentRect.width.toString() + "px";
  });
  mediaTag.resizeObserver.observe(mediaTag);
}
function processTag(mediaTag) {
  const canPlayClaim = mediaTag.canPlayType('audio/x-mpegurl');
  let supportsPlaylists = !!canPlayClaim;
  if (canPlayClaim == 'maybe') { // yes, seriously: specced as you only know when you try
    supportsPlaylists = false;
  }
  if (!supportsPlaylists) {
    if (isPlaylist(mediaTag.getAttribute("src"))) {
      initPlayer(mediaTag);
    }
  }
}
document.addEventListener('DOMContentLoaded', () => {
  const nodes = document.querySelectorAll("audio,video");
  nodes.forEach(processTag);
});
// @license-end
// The script:1 ends here
    </script>
    
</body>
</html>
